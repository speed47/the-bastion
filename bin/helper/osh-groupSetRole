#! /usr/bin/perl -T
# vim: set filetype=perl ts=4 sw=4 sts=4 et:
# KEYSUDOERS # as an owner, we can grant/revoke ownership
# KEYSUDOERS SUPEROWNERS, %%GROUP%-owner      ALL=(root)        NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-groupSetRole --type owner --group %GROUP% *
# KEYSUDOERS # as an owner, we can grant/revoke gatekeepership
# KEYSUDOERS SUPEROWNERS, %%GROUP%-owner      ALL=(root)        NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-groupSetRole --type gatekeeper --group %GROUP% *
# KEYSUDOERS # as an owner, we can grant/revoke aclkeepership
# KEYSUDOERS SUPEROWNERS, %%GROUP%-owner      ALL=(root)        NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-groupSetRole --type aclkeeper --group %GROUP% *
# KEYSUDOERS # as a gatekeeper, we can grant/revoke membership
# KEYSUDOERS SUPEROWNERS, %%GROUP%-gatekeeper ALL=(root)        NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-groupSetRole --type member --group %GROUP% *
# KEYSUDOERS # as a gatekeeper, we can grant/revoke a guest access
# KEYSUDOERS SUPEROWNERS, %%GROUP%-gatekeeper ALL=(root)        NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-groupSetRole --type guest --group %GROUP% *
# FILEMODE 0700
# FILEOWN 0 0

#>HEADER
use common::sense;
use Getopt::Long qw(:config no_auto_abbrev no_ignore_case);

use File::Basename;
use lib dirname(__FILE__) . '/../../lib/perl';
use OVH::Result;
use OVH::Bastion;
use OVH::Bastion::Plugin::groupSetRole;
use OVH::Bastion::Helper;

# Fetch command options
my $fnret;
my ($result, @optwarns);
my ($account, $group, $action, $role);
eval {
    local $SIG{__WARN__} = sub { push @optwarns, shift };
    $result = GetOptions(
        "type=s"    => sub { $role    //= $_[1] },
        "action=s"  => sub { $action  //= $_[1] },
        "group=s"   => sub { $group   //= $_[1] },    # ignore subsequent --group on cmdline (anti-sudoers-override)
        "account=s" => sub { $account //= $_[1] },
    );
};
if ($@) { die $@ }

if (!$result) {
    local $" = ", ";
    HEXIT('ERR_BAD_OPTIONS', msg => "Error parsing options: @optwarns");
}

OVH::Bastion::Helper::check_spurious_args();

osh_debug("groupSetRole: checking preconditions");
use Data::Dumper;
print Dumper("MIGRA in osh_groupsetrolee: self=$Self account=$account role=$role");
$fnret = OVH::Bastion::Plugin::groupSetRole::preconditions(
    Self           => $Self,
    account        => $account,
    group          => $group,
    action         => $action,
    role           => $role,
    isHelper       => 1,
    silentoverride => 1
);
osh_debug("groupSetRole: checking preconditions result: $fnret");
$fnret or HEXIT($fnret);
$role = $fnret->value->{'role'};
my $Account = $fnret->value->{'Account'};

my $Group = OVH::Bastion::Group->newFromSysGroup($group, check => 1);
$Group or HEXIT($Group);

my $shortGroup = $Group->name;
$group = $Group->sysGroup;
#<PARAMS:GROUP

#>RIGHTSCHECK
#done in Plugin::groupSetRole::preconditions
#<RIGHTSCHECK

#>CODE
if ($role eq 'owner') {
    $fnret = $Group->hasOwner($Account);
}
elsif ($role eq 'gatekeeper') {
    $fnret = $Group->hasGatekeeper($Account);
}
elsif ($role eq 'aclkeeper') {
    $fnret = $Group->hasAclkeeper($Account);
}
elsif ($role eq 'member') {
    $fnret = $Group->hasMember($Account);
}
elsif ($role eq 'guest') {
    $fnret = $Group->hasGuest($Account);
}
$fnret->is_err and HEXIT($fnret);

if ($action eq 'add' && $fnret->is_ok) {
    osh_debug("groupSetRole: Account $Account was already a $role of group $shortGroup, nothing to do");
    HEXIT('OK_NO_CHANGE', msg => "Account $Account was already a $role of group $shortGroup, nothing to do");
}
elsif ($action eq 'del' && $fnret->is_ko) {
    osh_debug("groupSetRole: Account $Account was not a $role of group $shortGroup, nothing to do");
    HEXIT('OK_NO_CHANGE', msg => "Account $Account was not a $role of group $shortGroup, nothing to do");
}

# add/del from sysgroup
my $groupName = ((grep { $role eq $_ } qw{ guest member }) ? $group : "$group-$role");

osh_debug("going to $action account $Account to/from $groupName");
$fnret = R('OK', silent => 1);
if ($action eq 'add') {

    if (!OVH::Bastion::is_user_in_group(user => $Account->sysUser, group => $groupName)) {
        $fnret = OVH::Bastion::sys_addmembertogroup(group => $groupName, user => $Account->sysUser, noisy_stderr => 1);
    }
}
elsif ($action eq 'del') {
    # for realm support accounts, maybe we must not delete the shared realm account from the group,
    # if other remote users are still members: check whether this account was the last one, of if there
    # are others
    my $otherMembers = 0;
    if ($Account->realm) {
        $fnret = $Account->getRemoteAccountsNames;
        $fnret or HEXIT($fnret);

        foreach my $remoteAccountName (@{$fnret->value}) {
            next if ($remoteAccountName eq $Account->remoteName);
            my $RemoteAccount = OVH::Bastion::Account->newFromName(sprintf("%s/%s", $Account->realm, $remoteAccountName), type => "remote");
            if ($RemoteAccount && $Group->hasMemberOrGuest($RemoteAccount)) {
                $otherMembers++;
                last;
            }
        }
    }
    if (!$otherMembers) {
        $fnret =
          OVH::Bastion::sys_delmemberfromgroup(group => $groupName, user => $Account->sysUser, noisy_stderr => 1);
    }
}
else {
    HEXIT('ERR_INTERNAL');    # unreachable
}
if ($fnret->err ne 'OK') {
    osh_debug('Unable to modify group: ' . $fnret->msg);
    HEXIT('ERR_INTERNAL', msg => "Error while doing $action on account $Account from $role list of $shortGroup");
}
osh_debug("groupSetRole: Account $action of $Account done on $role list of $shortGroup");
HEXIT('OK', msg => "Account $action of $Account done on $role list of $shortGroup");
